import { Match as M, Option, Schema as S } from 'effect'

import { html } from '../../html'
import type { Html, TagName } from '../../html'
import type { Command } from '../../runtime/runtime'
import { ts } from '../../schema'
import { evo } from '../../struct'
import * as Task from '../../task'

// MODEL

/** Schema for the disclosure component's state, tracking its unique ID and open/closed status. */
export const Model = S.Struct({
  id: S.String,
  isOpen: S.Boolean,
})

export type Model = typeof Model.Type

// MESSAGE

/** Sent when the disclosure button is clicked. Toggles the open/closed state. */
export const Toggled = ts('Toggled')
/** Sent to explicitly close the disclosure, regardless of its current state. */
export const Closed = ts('Closed')
/** Placeholder message used when no action is needed, such as after a focus command completes. */
export const NoOp = ts('NoOp')

/** Union of all messages the disclosure component can produce. */
export const Message = S.Union(Toggled, Closed, NoOp)

export type Toggled = typeof Toggled.Type
export type Closed = typeof Closed.Type
export type NoOp = typeof NoOp.Type

export type Message = typeof Message.Type

// INIT

/** Configuration for creating a disclosure model with `init`. */
export type InitConfig = Readonly<{
  id: string
  isOpen?: boolean
}>

/** Creates an initial disclosure model from a config. Defaults to closed. */
export const init = (config: InitConfig): Model => ({
  id: config.id,
  isOpen: config.isOpen ?? false,
})

// UPDATE

const buttonId = (id: string): string => `${id}-button`

const panelId = (id: string): string => `${id}-panel`

/** Processes a disclosure message and returns the next model and commands. */
export const update = (
  model: Model,
  message: Message,
): [Model, ReadonlyArray<Command<Message>>] =>
  M.value(message).pipe(
    M.withReturnType<[Model, ReadonlyArray<Command<Message>>]>(),
    M.tagsExhaustive({
      Toggled: () => {
        const maybeFocusCommand = Option.liftPredicate(
          Task.focus(`#${buttonId(model.id)}`, () => NoOp.make()),
          () => model.isOpen,
        )

        return [
          evo(model, { isOpen: () => !model.isOpen }),
          Option.toArray(maybeFocusCommand),
        ]
      },
      Closed: () => {
        const maybeFocusCommand = Option.liftPredicate(
          Task.focus(`#${buttonId(model.id)}`, () => NoOp.make()),
          () => model.isOpen,
        )

        return [
          evo(model, { isOpen: () => false }),
          Option.toArray(maybeFocusCommand),
        ]
      },
      NoOp: () => [model, []],
    }),
  )

// VIEW

/** Configuration for rendering a disclosure with `view`. */
export type ViewConfig<Message> = Readonly<{
  model: Model
  toMessage: (message: Toggled | Closed | NoOp) => Message
  buttonClassName: string
  buttonContent: Html
  panelClassName: string
  panelContent: Html
  isDisabled?: boolean
  persistPanel?: boolean
  buttonElement?: TagName
  panelElement?: TagName
  className?: string
}>

/** Renders a headless disclosure component with accessible ARIA attributes and keyboard support. */
export const view = <Message>(config: ViewConfig<Message>): Html => {
  const {
    div,
    empty,
    AriaControls,
    AriaDisabled,
    AriaExpanded,
    Class,
    DataAttribute,
    Disabled,
    Hidden,
    Id,
    OnClick,
    OnKeyDown,
    Tabindex,
    Type,
    keyed,
  } = html<Message>()

  const {
    model: { id, isOpen },
    toMessage,
    buttonClassName,
    buttonContent,
    panelClassName,
    panelContent,
    isDisabled,
    persistPanel,
    buttonElement = 'button',
    panelElement = 'div',
    className,
  } = config

  const isNativeButton = buttonElement === 'button'

  const handleKeyDown = (key: string): Message =>
    /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions */
    M.value(key).pipe(
      M.whenOr('Enter', ' ', () => toMessage(Toggled.make())),
      M.orElse(() => toMessage(NoOp.make())),
    ) as Message

  const disabledAttributes = [
    Disabled(true),
    AriaDisabled(true),
    DataAttribute('disabled', ''),
  ]

  const interactionAttributes = isDisabled
    ? disabledAttributes
    : [
        OnClick(toMessage(Toggled.make())),
        ...(!isNativeButton ? [OnKeyDown(handleKeyDown)] : []),
      ]

  const buttonAttributes = [
    Class(buttonClassName),
    Id(buttonId(id)),
    AriaExpanded(isOpen),
    AriaControls(panelId(id)),
    ...(isNativeButton ? [Type('button')] : [Tabindex(0)]),
    ...(isOpen ? [DataAttribute('open', '')] : []),
    ...interactionAttributes,
  ]

  const panelAttributes = [
    Class(panelClassName),
    Id(panelId(id)),
    ...(isOpen ? [DataAttribute('open', '')] : []),
  ]

  const persistedPanel = keyed(panelElement)(
    panelId(id),
    [...panelAttributes, Hidden(!isOpen)],
    [panelContent],
  )

  const activePanel = isOpen
    ? keyed(panelElement)(panelId(id), panelAttributes, [panelContent])
    : empty

  const panel = persistPanel ? persistedPanel : activePanel

  const wrapperAttributes = className ? [Class(className)] : []

  return div(wrapperAttributes, [
    keyed(buttonElement)(buttonId(id), buttonAttributes, [buttonContent]),
    panel,
  ])
}
